#!/usr/bin/env python3
"""
Claude Standards Synchronization Script

This script generates filtered files from CLAUDE_STANDARDS.md (the single source of truth):
1. claude.md - Filtered subset for automation compatibility
2. docs/CLAUDE_STANDARDS.md - Full copy for developer discoverability

Usage:
    python tools/sync_claude_standards.py [--claude-only] [--docs-only] [--check-only]
"""

import os
import sys
import re
from pathlib import Path
from datetime import datetime


class ClaudeStandardsSync:
    def __init__(self):
        # Determine project root (where CLAUDE_STANDARDS.md is located)
        self.project_root = Path(__file__).parent.parent.absolute()
        self.source_file = self.project_root / "CLAUDE_STANDARDS.md"
        self.claude_md_target = self.project_root / "claude.md" 
        self.docs_target = self.project_root / "docs" / "CLAUDE_STANDARDS.md"
        
        # Verify source file exists
        if not self.source_file.exists():
            raise FileNotFoundError(f"Source file not found: {self.source_file}")
    
    def read_source_content(self):
        """Read the source CLAUDE_STANDARDS.md file"""
        with open(self.source_file, 'r', encoding='utf-8') as f:
            return f.read()
    
    def generate_claude_md_content(self, source_content):
        """Generate filtered claude.md content for automation compatibility"""
        
        # Extract sections that automation needs
        sections_to_include = [
            "TODO MANAGEMENT PROTOCOL",
            "UPDATE PROTOCOL", 
            "Core Directory Structure",
            "Essential File Organization Rules",
            "Path Management",
            "State File Management Standards",
            "Configuration",
            "Security Considerations",
            "Output Safety Rules",
            "CRITICAL IMPLEMENTATION NOTES"
        ]
        
        lines = source_content.split('\n')
        filtered_lines = []
        current_section = None
        include_current = False
        section_depth = 0
        
        # Add header
        filtered_lines.extend([
            "# CLAUDE.MD - Amazon FBA Agent System v3.5 File Organization & Development Standards",
            "",
            "## üéØ Purpose", 
            "This document establishes the standardized file organization system for the Amazon FBA Agent System v3.5. All scripts, tools, and processes MUST follow these conventions to maintain consistency, enable proper automation, and ensure maintainability.",
            "",
            "‚ö†Ô∏è **AUTO-GENERATED FILE**: This file is automatically generated from CLAUDE_STANDARDS.md. DO NOT EDIT DIRECTLY.",
            f"**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"**Source**: CLAUDE_STANDARDS.md",
            "",
            "---",
            ""
        ])
        
        for line in lines:
            # Check if this is a heading
            if line.startswith('#'):
                heading_level = len(line) - len(line.lstrip('#'))
                heading_text = line.lstrip('#').strip()
                
                # Check if this section should be included
                include_current = any(section in heading_text for section in sections_to_include)
                
                if include_current:
                    current_section = heading_text
                    section_depth = heading_level
                    filtered_lines.append(line)
                else:
                    # Check if we're in a subsection of an included section
                    if current_section and heading_level > section_depth:
                        filtered_lines.append(line)
                    else:
                        current_section = None
                        include_current = False
            
            elif include_current or current_section:
                # Include line if we're in an included section
                filtered_lines.append(line)
        
        # Add footer
        filtered_lines.extend([
            "",
            "---",
            "",
            f"**Last Updated**: {datetime.now().strftime('%Y-%m-%d')}",
            "**Version**: 3.6",
            "**Maintained By**: Amazon FBA Agent System Team",
            "**Status**: ACTIVE STANDARD - All development must comply",
            "",
            "**‚ö†Ô∏è NOTICE**: This file is auto-generated from CLAUDE_STANDARDS.md. For complete development guidance, see CLAUDE_STANDARDS.md"
        ])
        
        return '\n'.join(filtered_lines)
    
    def generate_docs_content(self, source_content):
        """Generate docs/CLAUDE_STANDARDS.md with auto-generated header"""
        
        header = f"""<!-- AUTO-GENERATED: DO NOT EDIT DIRECTLY -->
<!-- This file is automatically synced from ../CLAUDE_STANDARDS.md -->
<!-- Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} -->
<!-- Source: ../CLAUDE_STANDARDS.md -->

"""
        return header + source_content
    
    def write_file(self, target_path, content):
        """Write content to target file, creating directories if needed"""
        target_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(target_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"‚úÖ Generated: {target_path}")
    
    def sync_claude_md(self):
        """Generate claude.md from CLAUDE_STANDARDS.md"""
        print("üìÑ Generating claude.md (filtered for automation)...")
        
        source_content = self.read_source_content()
        claude_content = self.generate_claude_md_content(source_content)
        self.write_file(self.claude_md_target, claude_content)
        
        return True
    
    def sync_docs(self):
        """Generate docs/CLAUDE_STANDARDS.md from CLAUDE_STANDARDS.md"""
        print("üìÑ Generating docs/CLAUDE_STANDARDS.md (full copy for discoverability)...")
        
        source_content = self.read_source_content()
        docs_content = self.generate_docs_content(source_content)
        self.write_file(self.docs_target, docs_content)
        
        return True
    
    def sync_all(self):
        """Generate both claude.md and docs/CLAUDE_STANDARDS.md"""
        print("üîÑ Syncing Claude Standards files...")
        print(f"üìÇ Source: {self.source_file}")
        
        success = True
        
        try:
            success &= self.sync_claude_md()
            success &= self.sync_docs()
            
            if success:
                print("\n‚úÖ All files synced successfully!")
                print("\nüìã Generated files:")
                print(f"   ‚Ä¢ {self.claude_md_target} (automation target)")
                print(f"   ‚Ä¢ {self.docs_target} (developer discoverability)")
                print(f"\nüí° Source of truth: {self.source_file}")
            
        except Exception as e:
            print(f"\n‚ùå Error during sync: {e}")
            success = False
        
        return success
    
    def check_sync_needed(self):
        """Check if files need to be synced"""
        try:
            source_content = self.read_source_content()
            
            # Generate what claude.md should be
            expected_claude_content = self.generate_claude_md_content(source_content)
            
            # Read current claude.md if it exists
            if self.claude_md_target.exists():
                with open(self.claude_md_target, 'r', encoding='utf-8') as f:
                    current_claude_content = f.read()
            else:
                current_claude_content = ""
            
            # Generate what docs/CLAUDE_STANDARDS.md should be
            expected_docs_content = self.generate_docs_content(source_content)
            
            # Read current docs/CLAUDE_STANDARDS.md if it exists
            if self.docs_target.exists():
                with open(self.docs_target, 'r', encoding='utf-8') as f:
                    current_docs_content = f.read()
            else:
                current_docs_content = ""
            
            # Compare contents (normalize line endings)
            claude_needs_sync = expected_claude_content.replace('\r\n', '\n') != current_claude_content.replace('\r\n', '\n')
            docs_needs_sync = expected_docs_content.replace('\r\n', '\n') != current_docs_content.replace('\r\n', '\n')
            
            if claude_needs_sync or docs_needs_sync:
                reasons = []
                if claude_needs_sync:
                    reasons.append("claude.md")
                if docs_needs_sync:
                    reasons.append("docs/CLAUDE_STANDARDS.md")
                print(f"‚ùå Sync needed for: {', '.join(reasons)}")
                return False
            else:
                print("‚úÖ All files are in sync")
                return True
                
        except Exception as e:
            print(f"‚ùå Check failed: {e}")
            return False


def main():
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Sync Claude Standards files')
    parser.add_argument('--claude-only', action='store_true', 
                       help='Only generate claude.md')
    parser.add_argument('--docs-only', action='store_true',
                       help='Only generate docs/CLAUDE_STANDARDS.md')
    parser.add_argument('--check-only', action='store_true',
                       help='Check if files need sync (exit 0=synced, 1=needs sync)')
    
    args = parser.parse_args()
    
    try:
        syncer = ClaudeStandardsSync()
        
        if args.check_only:
            success = syncer.check_sync_needed()
        elif args.claude_only:
            success = syncer.sync_claude_md()
        elif args.docs_only:
            success = syncer.sync_docs()
        else:
            success = syncer.sync_all()
        
        sys.exit(0 if success else 1)
        
    except Exception as e:
        print(f"‚ùå Fatal error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()