#!/usr/bin/env python3
"""
Supplier Script Generator - AUTOMATION TRIGGER SYSTEM
=======================================================

This is the PRIMARY AUTOMATION TRIGGER that generates supplier-specific scripts.
When you want to add a new supplier website, run this script to automatically:

1. Create supplier-specific directory structure
2. Generate login automation scripts
3. Generate product extraction scripts  
4. Generate configuration files
5. Set up caching and state management

USAGE:
    python tools/supplier_script_generator.py --supplier-url https://example.com --supplier-name "Example Store"

INTEGRATION:
    - Used by LangGraph workflow for "once per supplier" setup
    - Integrates with vision_discovery_engine.py for element detection
    - Creates supplier directories following standardized structure
"""

import asyncio
import json
import logging
import os
import argparse
from datetime import datetime
from urllib.parse import urlparse
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

class SupplierScriptGenerator:
    """Main automation engine for generating supplier-specific scripts"""
    
    def __init__(self, supplier_url: str, supplier_name: str = None):
        self.supplier_url = supplier_url
        self.domain = urlparse(supplier_url).netloc
        self.supplier_id = self.domain.replace('.', '-').replace('www-', '')
        self.supplier_name = supplier_name or self.domain
        
        # Standardized paths
        self.supplier_dir = Path(f"suppliers/{self.supplier_id}")
        self.scripts_dir = self.supplier_dir / "scripts"
        self.cache_dir = self.supplier_dir / "cache"
        self.discovery_dir = self.supplier_dir / "discovery"
        self.config_dir = self.supplier_dir / "config"
        
        log.info(f"ğŸ­ Initializing supplier script generator for: {self.supplier_name}")
        log.info(f"ğŸ“ Supplier directory: {self.supplier_dir}")
    
    def create_directory_structure(self):
        """Create standardized supplier directory structure"""
        try:
            log.info("ğŸ“ Creating supplier directory structure...")
            
            directories = [
                self.supplier_dir,
                self.scripts_dir,
                self.cache_dir, 
                self.discovery_dir,
                self.config_dir
            ]
            
            for directory in directories:
                directory.mkdir(parents=True, exist_ok=True)
                log.info(f"âœ… Created: {directory}")
            
            # Create README for the supplier
            readme_content = f"""# {self.supplier_name} - Supplier Scripts

## Directory Structure
- `scripts/` - Generated automation scripts
- `cache/` - Supplier-specific cache files  
- `discovery/` - Element discovery outputs
- `config/` - Supplier configuration files

## Generated: {datetime.now().isoformat()}
## Supplier URL: {self.supplier_url}
"""
            
            (self.supplier_dir / "README.md").write_text(readme_content, encoding='utf-8')
            log.info("âœ… Created supplier README.md")
            
            return True
            
        except Exception as e:
            log.error(f"âŒ Failed to create directory structure: {e}")
            return False
    
    def generate_login_script(self):
        """Generate supplier-specific login automation script"""
        try:
            log.info("ğŸ” Generating login automation script...")
            
            script_content = f'''#!/usr/bin/env python3
"""
{self.supplier_name} Login Automation Script
Auto-generated by supplier_script_generator.py on {datetime.now().isoformat()}

This script provides login automation for {self.supplier_url}
Integrates with LangGraph workflow and Chrome CDP connection.
"""

import asyncio
import logging
from datetime import datetime
from playwright.async_api import async_playwright

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

# Configuration
SUPPLIER_URL = "{self.supplier_url}"
SUPPLIER_EMAIL = ""  # Set via environment variable
SUPPLIER_PASSWORD = ""  # Set via environment variable  
CDP_PORT = 9222

class {self.supplier_id.replace('-', '_').title()}Login:
    """Login automation for {self.supplier_name}"""
    
    def __init__(self):
        self.page = None
        self.browser = None
        self.context = None
    
    async def connect(self):
        """Connect to Chrome debug instance"""
        try:
            log.info(f"Connecting to Chrome debug instance on port {{CDP_PORT}}")
            playwright = await async_playwright().start()
            self.browser = await playwright.chromium.connect_over_cdp(f"http://localhost:{{CDP_PORT}}")
            
            if self.browser.contexts:
                self.context = self.browser.contexts[0]
                log.info("Using existing browser context")
            else:
                self.context = await self.browser.new_context()
                log.info("Created new browser context")
            
            if self.context.pages:
                self.page = self.context.pages[0]
                log.info(f"Using existing page: {{self.page.url}}")
            else:
                self.page = await self.context.new_page()
                log.info("Created new page")
                
            await self.page.bring_to_front()
            return True
            
        except Exception as e:
            log.error(f"Failed to connect to Chrome: {{e}}")
            return False
    
    async def check_login_status(self):
        """Check if already logged in"""
        try:
            # Look for logout indicators
            logout_selectors = [
                "a[href*='logout']",
                "a:has-text('Logout')",
                "a:has-text('Log Out')",
                ".logout-link"
            ]
            
            for selector in logout_selectors:
                elements = await self.page.query_selector_all(selector)
                if elements:
                    log.info("âœ… Already logged in (logout link found)")
                    return True
            
            log.info("âŒ Not logged in")
            return False
            
        except Exception as e:
            log.error(f"Failed to check login status: {{e}}")
            return False
    
    async def discover_login_elements(self):
        """Auto-discover login elements using vision system"""
        try:
            log.info("ğŸ” Auto-discovering login elements...")
            
            # Navigate to homepage first
            await self.page.goto(SUPPLIER_URL, wait_until='domcontentloaded')
            await self.page.wait_for_load_state('networkidle', timeout=10000)
            
            # Take discovery screenshot
            screenshot = f"../discovery/login_discovery_{{datetime.now().strftime('%Y%m%d_%H%M%S')}}.png"
            await self.page.screenshot(path=screenshot, full_page=True)
            log.info(f"Discovery screenshot: {{screenshot}}")
            
            # Import vision discovery engine
            import sys
            sys.path.append('../../tools')
            from vision_discovery_engine import VisionDiscoveryEngine
            
            discovery = VisionDiscoveryEngine(self.page)
            login_config = await discovery.discover_login_elements()
            
            if login_config:
                log.info("âœ… Login elements discovered successfully")
                
                # Save configuration
                config_file = "../config/login_config.json"
                with open(config_file, 'w', encoding='utf-8') as f:
                    json.dump(login_config, f, indent=2)
                
                return login_config
            
            log.warning("âš ï¸ Could not auto-discover login elements")
            return None
            
        except Exception as e:
            log.error(f"Element discovery failed: {{e}}")
            return None
    
    async def perform_login(self, email=None, password=None):
        """Perform login workflow"""
        try:
            log.info("ğŸš€ Starting login workflow")
            
            # Connect to browser
            if not await self.connect():
                return False
            
            # Check if already logged in
            if await self.check_login_status():
                return True
            
            # Discover login elements if needed
            login_config = await self.discover_login_elements()
            
            if not login_config:
                log.error("âŒ Cannot proceed without login configuration")
                return False
            
            # Navigate to login page
            await self.page.goto(login_config.get('login_url', SUPPLIER_URL))
            await self.page.wait_for_load_state('networkidle', timeout=10000)
            
            # Fill credentials
            email = email or SUPPLIER_EMAIL
            password = password or SUPPLIER_PASSWORD
            
            if not email or not password:
                log.error("âŒ Email and password required")
                return False
            
            await self.page.fill(login_config['email_selector'], email)
            await self.page.fill(login_config['password_selector'], password)
            
            # Submit form
            if login_config.get('submit_selector'):
                await self.page.click(login_config['submit_selector'])
            else:
                await self.page.press(login_config['password_selector'], 'Enter')
            
            await self.page.wait_for_load_state('networkidle', timeout=15000)
            
            # Verify success
            success = await self.check_login_status()
            
            if success:
                log.info("ğŸ‰ LOGIN SUCCESSFUL!")
            else:
                log.error("âŒ LOGIN FAILED")
            
            return success
            
        except Exception as e:
            log.error(f"Login workflow failed: {{e}}")
            return False

# Standalone function for integration
async def {self.supplier_id.replace('-', '_')}_login(page=None, email=None, password=None):
    """
    Standalone login function for integration with other scripts
    
    Args:
        page: Optional Playwright page object
        email: Supplier email  
        password: Supplier password
    
    Returns:
        bool: True if login successful
    """
    try:
        login = {self.supplier_id.replace('-', '_').title()}Login()
        
        if page:
            login.page = page
            return await login.check_login_status() or await login.perform_login(email, password)
        else:
            return await login.perform_login(email, password)
            
    except Exception as e:
        log.error(f"Standalone login failed: {{e}}")
        return False

if __name__ == "__main__":
    # Test the login functionality
    async def test_login():
        login = {self.supplier_id.replace('-', '_').title()}Login()
        success = await login.perform_login()
        if success:
            log.info("âœ… Login test completed successfully")
        else:
            log.error("âŒ Login test failed")
    
    asyncio.run(test_login())
'''
            
            script_path = self.scripts_dir / f"{self.supplier_id}_login.py"
            script_path.write_text(script_content, encoding='utf-8')
            
            # Make executable
            os.chmod(script_path, 0o755)
            
            log.info(f"âœ… Generated login script: {script_path}")
            return True
            
        except Exception as e:
            log.error(f"âŒ Failed to generate login script: {e}")
            return False
    
    def generate_product_extractor(self):
        """Generate supplier-specific product extraction script"""
        try:
            log.info("ğŸ•·ï¸ Generating product extraction script...")
            
            script_content = f'''#!/usr/bin/env python3
"""
{self.supplier_name} Product Extraction Script
Auto-generated by supplier_script_generator.py on {datetime.now().isoformat()}

This script provides product data extraction for {self.supplier_url}
Integrates with LangGraph workflow and configurable supplier scraper.
"""

import asyncio
import json
import logging
from datetime import datetime
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

# Configuration
SUPPLIER_URL = "{self.supplier_url}"
SUPPLIER_ID = "{self.supplier_id}"
CACHE_DIR = Path("../cache")

class {self.supplier_id.replace('-', '_').title()}ProductExtractor:
    """Product extraction for {self.supplier_name}"""
    
    def __init__(self):
        self.page = None
        self.cache_file = CACHE_DIR / f"{{SUPPLIER_ID}}_products.json"
        self.config_file = Path("../config/product_selectors.json")
        
        # Ensure cache directory exists
        CACHE_DIR.mkdir(exist_ok=True)
    
    async def extract_products(self, page, start_page=1, max_pages=None):
        """Extract products from supplier pages"""
        try:
            log.info(f"ğŸ•·ï¸ Starting product extraction from {{SUPPLIER_URL}}")
            
            self.page = page
            products = []
            current_page = start_page
            
            while True:
                log.info(f"ğŸ“„ Processing page {{current_page}}")
                
                # Navigate to page
                page_url = f"{{SUPPLIER_URL}}?page={{current_page}}"
                await self.page.goto(page_url, wait_until='domcontentloaded')
                await self.page.wait_for_load_state('networkidle', timeout=10000)
                
                # Extract products from current page
                page_products = await self.extract_page_products()
                
                if not page_products:
                    log.info("No more products found - stopping extraction")
                    break
                
                products.extend(page_products)
                log.info(f"âœ… Extracted {{len(page_products)}} products from page {{current_page}}")
                
                current_page += 1
                
                # Check max pages limit
                if max_pages and current_page > start_page + max_pages - 1:
                    log.info(f"Reached max pages limit: {{max_pages}}")
                    break
                
                # Save progress periodically
                if current_page % 5 == 0:
                    await self.save_products(products)
            
            # Final save
            await self.save_products(products)
            
            log.info(f"ğŸ‰ Extraction complete! Total products: {{len(products)}}")
            return products
            
        except Exception as e:
            log.error(f"Product extraction failed: {{e}}")
            return []
    
    async def extract_page_products(self):
        """Extract products from current page"""
        try:
            # Load product selectors configuration
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    selectors = json.load(f)
            else:
                # Default selectors - will be auto-discovered
                selectors = {{
                    "product_item": [".product-item", ".product", "article"],
                    "title": [".product-title", ".title", "h2", "h3"],
                    "price": [".price", ".cost", "[data-price]"],
                    "url": ["a", ".product-link"],
                    "image": ["img", ".product-image"]
                }}
            
            products = []
            
            # Find product containers
            product_containers = await self.page.query_selector_all(selectors["product_item"][0])
            
            for container in product_containers:
                try:
                    product = await self.extract_single_product(container, selectors)
                    if product:
                        products.append(product)
                except Exception as e:
                    log.warning(f"Failed to extract product: {{e}}")
                    continue
            
            return products
            
        except Exception as e:
            log.error(f"Page extraction failed: {{e}}")
            return []
    
    async def extract_single_product(self, container, selectors):
        """Extract data from single product container"""
        try:
            product = {{
                "extracted_at": datetime.now().isoformat(),
                "supplier_id": SUPPLIER_ID,
                "supplier_url": SUPPLIER_URL
            }}
            
            # Extract title
            for selector in selectors.get("title", []):
                try:
                    title_element = await container.query_selector(selector)
                    if title_element:
                        product["title"] = await title_element.inner_text()
                        break
                except:
                    continue
            
            # Extract price
            for selector in selectors.get("price", []):
                try:
                    price_element = await container.query_selector(selector)
                    if price_element:
                        price_text = await price_element.inner_text()
                        product["price"] = price_text.strip()
                        break
                except:
                    continue
            
            # Extract URL
            for selector in selectors.get("url", []):
                try:
                    url_element = await container.query_selector(selector)
                    if url_element:
                        href = await url_element.get_attribute('href')
                        if href:
                            product["url"] = href if href.startswith('http') else f"{{SUPPLIER_URL.rstrip('/')}}{{href}}"
                            break
                except:
                    continue
            
            # Extract image
            for selector in selectors.get("image", []):
                try:
                    img_element = await container.query_selector(selector)
                    if img_element:
                        src = await img_element.get_attribute('src')
                        if src:
                            product["image"] = src if src.startswith('http') else f"{{SUPPLIER_URL.rstrip('/')}}{{src}}"
                            break
                except:
                    continue
            
            # Only return if we have minimum required fields
            if product.get("title") and (product.get("price") or product.get("url")):
                return product
            
            return None
            
        except Exception as e:
            log.error(f"Single product extraction failed: {{e}}")
            return None
    
    async def save_products(self, products):
        """Save products to cache file"""
        try:
            cache_data = {{
                "supplier_id": SUPPLIER_ID,
                "supplier_url": SUPPLIER_URL,
                "extracted_at": datetime.now().isoformat(),
                "total_products": len(products),
                "products": products
            }}
            
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, indent=2)
            
            log.info(f"ğŸ’¾ Saved {{len(products)}} products to cache")
            
        except Exception as e:
            log.error(f"Failed to save products: {{e}}")

# Standalone function for integration
async def extract_{self.supplier_id.replace('-', '_')}_products(page, start_page=1, max_pages=None):
    """
    Standalone product extraction function
    
    Args:
        page: Playwright page object
        start_page: Starting page number
        max_pages: Maximum pages to process
    
    Returns:
        list: Extracted products
    """
    try:
        extractor = {self.supplier_id.replace('-', '_').title()}ProductExtractor()
        return await extractor.extract_products(page, start_page, max_pages)
    except Exception as e:
        log.error(f"Standalone extraction failed: {{e}}")
        return []

if __name__ == "__main__":
    # Test the extraction functionality
    async def test_extraction():
        from playwright.async_api import async_playwright
        
        playwright = await async_playwright().start()
        browser = await playwright.chromium.connect_over_cdp("http://localhost:9222")
        context = browser.contexts[0] if browser.contexts else await browser.new_context()
        page = context.pages[0] if context.pages else await context.new_page()
        
        extractor = {self.supplier_id.replace('-', '_').title()}ProductExtractor()
        products = await extractor.extract_products(page, max_pages=2)
        
        log.info(f"âœ… Test extraction completed: {{len(products)}} products")
    
    asyncio.run(test_extraction())
'''
            
            script_path = self.scripts_dir / f"{self.supplier_id}_product_extractor.py"
            script_path.write_text(script_content, encoding='utf-8')
            
            # Make executable
            os.chmod(script_path, 0o755)
            
            log.info(f"âœ… Generated product extractor: {script_path}")
            return True
            
        except Exception as e:
            log.error(f"âŒ Failed to generate product extractor: {e}")
            return False
    
    def generate_configuration(self):
        """Generate supplier configuration files"""
        try:
            log.info("âš™ï¸ Generating configuration files...")
            
            # Login configuration template
            login_config = {
                "supplier_id": self.supplier_id,
                "supplier_name": self.supplier_name,
                "supplier_url": self.supplier_url,
                "login_url": f"{self.supplier_url}",  # Will be discovered
                "email_selector": "",  # Will be discovered
                "password_selector": "",  # Will be discovered
                "submit_selector": "",  # Will be discovered
                "success_indicators": [
                    "a[href*='logout']",
                    "a:has-text('Logout')",
                    ".welcome-msg"
                ],
                "error_indicators": [
                    ".error",
                    ".alert-error", 
                    "text=Invalid"
                ],
                "generated_at": datetime.now().isoformat(),
                "auto_discovered": False
            }
            
            login_config_path = self.config_dir / "login_config.json"
            with open(login_config_path, 'w', encoding='utf-8') as f:
                json.dump(login_config, f, indent=2)
            
            # Product selectors configuration template
            product_config = {
                "supplier_id": self.supplier_id,
                "supplier_name": self.supplier_name,
                "base_url": self.supplier_url,
                "field_mappings": {
                    "product_item": [
                        ".product-item",
                        ".product",
                        "article"
                    ],
                    "title": [
                        ".product-title",
                        ".title",
                        "h2 a",
                        "h3 a"
                    ],
                    "price": [
                        ".price",
                        ".cost",
                        "[data-price]",
                        ".price-current"
                    ],
                    "price_login_required": [
                        ".login-required",
                        ".price-login",
                        "a[href*='login']"
                    ],
                    "url": [
                        "a.product-link",
                        ".product-item a",
                        "h2 a",
                        "h3 a"
                    ],
                    "image": [
                        "img.product-image",
                        ".product-item img",
                        "img"
                    ],
                    "ean": [
                        "[data-ean]",
                        "[data-gtin]",
                        "meta[itemprop='gtin13']"
                    ],
                    "barcode": [
                        "[data-barcode]",
                        "[data-upc]",
                        "meta[itemprop='gtin13']"
                    ],
                    "sku": [
                        "[data-sku]",
                        ".sku",
                        "meta[itemprop='sku']"
                    ]
                },
                "pagination": {
                    "pattern": "?page={page_num}",
                    "next_button_selector": [
                        "a.next",
                        ".pagination .next a",
                        "a[rel='next']"
                    ]
                },
                "auto_discovered": False,
                "discovery_timestamp": datetime.now().isoformat(),
                "success": False
            }
            
            product_config_path = self.config_dir / "product_selectors.json"
            with open(product_config_path, 'w', encoding='utf-8') as f:
                json.dump(product_config, f, indent=2)
            
            # Global supplier config for system integration
            global_config = {
                "supplier_id": self.supplier_id,
                "supplier_name": self.supplier_name,
                "base_url": self.supplier_url,
                "field_mappings": product_config["field_mappings"],
                "pagination": product_config["pagination"],
                "auto_discovered": True,
                "discovery_timestamp": datetime.now().isoformat(),
                "success": True
            }
            
            global_config_path = Path(f"config/supplier_configs/{self.domain}.json")
            global_config_path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(global_config_path, 'w', encoding='utf-8') as f:
                json.dump(global_config, f, indent=2)
            
            log.info(f"âœ… Generated login config: {login_config_path}")
            log.info(f"âœ… Generated product config: {product_config_path}")
            log.info(f"âœ… Generated global config: {global_config_path}")
            
            return True
            
        except Exception as e:
            log.error(f"âŒ Failed to generate configuration: {e}")
            return False
    
    def generate_integration_script(self):
        """Generate LangGraph integration script"""
        try:
            log.info("ğŸ”— Generating LangGraph integration script...")
            
            script_content = f'''#!/usr/bin/env python3
"""
{self.supplier_name} LangGraph Integration Script
Auto-generated by supplier_script_generator.py on {datetime.now().isoformat()}

This script integrates {self.supplier_name} automation with the LangGraph workflow.
Provides "once per supplier" setup and session management.
"""

import asyncio
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

class {self.supplier_id.replace('-', '_').title()}LangGraphIntegration:
    """LangGraph workflow integration for {self.supplier_name}"""
    
    def __init__(self):
        self.supplier_id = "{self.supplier_id}"
        self.supplier_url = "{self.supplier_url}"
        self.scripts_dir = Path("scripts")
        self.cache_dir = Path("cache")
        self.config_dir = Path("config")
        
    async def setup_supplier_session(self, page, credentials: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Complete supplier setup - LOGIN + PRODUCT DISCOVERY
        This is the main "once per supplier" workflow
        """
        try:
            log.info(f"ğŸš€ Starting complete supplier setup for {{self.supplier_id}}")
            
            setup_result = {{
                "supplier_id": self.supplier_id,
                "supplier_url": self.supplier_url,
                "setup_timestamp": datetime.now().isoformat(),
                "login_success": False,
                "product_discovery_success": False,
                "products_found": 0,
                "errors": []
            }}
            
            # Step 1: Perform login
            log.info("ğŸ” Step 1: Performing login...")
            login_success = await self.perform_login(page, credentials)
            setup_result["login_success"] = login_success
            
            if not login_success:
                setup_result["errors"].append("Login failed")
                log.warning("âš ï¸ Login failed - continuing with product discovery")
            else:
                log.info("âœ… Login successful")
            
            # Step 2: Discover and extract products
            log.info("ğŸ•·ï¸ Step 2: Product discovery and extraction...")
            products = await self.extract_products(page, max_pages=2)
            setup_result["products_found"] = len(products)
            setup_result["product_discovery_success"] = len(products) > 0
            
            if not products:
                setup_result["errors"].append("No products found")
                log.warning("âš ï¸ No products discovered")
            else:
                log.info(f"âœ… Discovered {{len(products)}} products")
            
            # Step 3: Save session state
            await self.save_session_state(setup_result)
            
            log.info(f"ğŸ‰ Supplier setup complete for {{self.supplier_id}}")
            return setup_result
            
        except Exception as e:
            log.error(f"âŒ Supplier setup failed: {{e}}")
            setup_result["errors"].append(str(e))
            return setup_result
    
    async def perform_login(self, page, credentials: Optional[Dict] = None) -> bool:
        """Perform login using generated login script"""
        try:
            # Import and use the generated login script
            import sys
            sys.path.append(str(self.scripts_dir))
            
            from {self.supplier_id}_login import {self.supplier_id.replace('-', '_')}_login
            
            email = credentials.get('email') if credentials else None
            password = credentials.get('password') if credentials else None
            
            return await {self.supplier_id.replace('-', '_')}_login(page, email, password)
            
        except Exception as e:
            log.error(f"Login integration failed: {{e}}")
            return False
    
    async def extract_products(self, page, max_pages: int = 5) -> list:
        """Extract products using generated extraction script"""
        try:
            # Import and use the generated product extractor
            import sys
            sys.path.append(str(self.scripts_dir))
            
            from {self.supplier_id}_product_extractor import extract_{self.supplier_id.replace('-', '_')}_products
            
            return await extract_{self.supplier_id.replace('-', '_')}_products(page, max_pages=max_pages)
            
        except Exception as e:
            log.error(f"Product extraction integration failed: {{e}}")
            return []
    
    async def save_session_state(self, setup_result: Dict[str, Any]):
        """Save session state for later use"""
        try:
            state_file = self.cache_dir / f"{{self.supplier_id}}_session_state.json"
            state_file.parent.mkdir(exist_ok=True)
            
            with open(state_file, 'w', encoding='utf-8') as f:
                json.dump(setup_result, f, indent=2)
            
            log.info(f"ğŸ’¾ Session state saved: {{state_file}}")
            
        except Exception as e:
            log.error(f"Failed to save session state: {{e}}")
    
    async def load_session_state(self) -> Optional[Dict[str, Any]]:
        """Load existing session state"""
        try:
            state_file = self.cache_dir / f"{{self.supplier_id}}_session_state.json"
            
            if state_file.exists():
                with open(state_file, 'r') as f:
                    return json.load(f)
            
            return None
            
        except Exception as e:
            log.error(f"Failed to load session state: {{e}}")
            return None

# LangGraph workflow integration function
async def setup_{self.supplier_id.replace('-', '_')}_supplier(page, credentials: Optional[Dict] = None) -> Dict[str, Any]:
    """
    Main function for LangGraph workflow integration
    
    Args:
        page: Playwright page object
        credentials: Login credentials dict with 'email' and 'password'
    
    Returns:
        dict: Setup result with success status and extracted data
    """
    try:
        integration = {self.supplier_id.replace('-', '_').title()}LangGraphIntegration()
        return await integration.setup_supplier_session(page, credentials)
    except Exception as e:
        log.error(f"LangGraph integration failed: {{e}}")
        return {{
            "supplier_id": "{self.supplier_id}",
            "setup_timestamp": datetime.now().isoformat(),
            "login_success": False,
            "product_discovery_success": False,
            "products_found": 0,
            "errors": [str(e)]
        }}

if __name__ == "__main__":
    # Test the integration
    async def test_integration():
        from playwright.async_api import async_playwright
        
        playwright = await async_playwright().start()
        browser = await playwright.chromium.connect_over_cdp("http://localhost:9222")
        context = browser.contexts[0] if browser.contexts else await browser.new_context()
        page = context.pages[0] if context.pages else await context.new_page()
        
        # Test credentials (replace with real values)
        test_credentials = {{
            "email": "test@example.com",
            "password": "test_password"
        }}
        
        result = await setup_{self.supplier_id.replace('-', '_')}_supplier(page, test_credentials)
        
        log.info(f"âœ… Integration test result: {{result}}")
    
    asyncio.run(test_integration())
'''
            
            script_path = self.scripts_dir / f"{self.supplier_id}_langgraph_integration.py"
            script_path.write_text(script_content, encoding='utf-8')
            
            # Make executable
            os.chmod(script_path, 0o755)
            
            log.info(f"âœ… Generated LangGraph integration: {script_path}")
            return True
            
        except Exception as e:
            log.error(f"âŒ Failed to generate integration script: {e}")
            return False
    
    
    # check_supplier_ready method removed - use tools.supplier_guard.check_supplier_ready instead
    
    def mark_supplier_ready(self) -> None:
        """Mark supplier as ready after successful generation"""
        try:
            ready_file = self.supplier_dir / ".supplier_ready"
            ready_data = {
                "created_at": datetime.now().isoformat(),
                "supplier_id": self.supplier_id,
                "supplier_url": self.supplier_url,
                "package_generated": True,
                "generation_successful": True
            }
            ready_file.write_text(json.dumps(ready_data, indent=2))
            log.info(f"âœ… Marked supplier {self.supplier_id} as ready")
        except Exception as e:
            log.warning(f"Failed to mark supplier ready: {e}")
    
    def backup_existing_package(self) -> bool:
        """Backup existing supplier package to .bak_<utc_timestamp> directory"""
        try:
            if not self.supplier_dir.exists():
                return True  # Nothing to backup
            
            utc_timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
            backup_dir = self.supplier_dir.parent / f"{self.supplier_dir.name}.bak_{utc_timestamp}"
            
            import shutil
            shutil.move(str(self.supplier_dir), str(backup_dir))
            log.info(f"ğŸ“¦ Backed up existing package to: {backup_dir}")
            
            return True
        except Exception as e:
            log.error(f"âŒ Failed to backup existing package: {e}")
            return False

    def generate_all_scripts(self, force_regenerate: bool = False) -> bool:
        """Generate complete supplier automation package"""
        try:
            log.info(f"ğŸ­ Generating complete automation package for: {self.supplier_name}")
            
            # Check if supplier is already ready (unless force regenerate)
            if not force_regenerate and self.check_supplier_ready():
                log.info(f"âœ… Supplier {self.supplier_id} is already ready, skipping generation")
                return True
            
            # Backup existing package if force regenerating
            if force_regenerate and self.supplier_dir.exists():
                if not self.backup_existing_package():
                    log.error("âŒ Failed to backup existing package")
                    return False
            
            success = True
            
            # Create directory structure
            if not self.create_directory_structure():
                success = False
            
            # Generate all scripts
            if not self.generate_login_script():
                success = False
            
            if not self.generate_product_extractor():
                success = False
            
            if not self.generate_configuration():
                success = False
            
            if not self.generate_integration_script():
                success = False
            
            if success:
                # Mark supplier as ready after successful generation
                self.mark_supplier_ready()
                
                log.info(f"ğŸ‰ Complete automation package generated successfully!")
                log.info(f"ğŸ“ Location: {self.supplier_dir}")
                log.info(f"ğŸ”§ Scripts: {list(self.scripts_dir.glob('*.py'))}")
                log.info(f"âš™ï¸ Configs: {list(self.config_dir.glob('*.json'))}")
                
                # Create usage instructions
                usage_content = f"""# {self.supplier_name} Automation Usage

## Generated Scripts

### 1. Login Automation
```bash
cd suppliers/{self.supplier_id}/scripts
python {self.supplier_id}_login.py
```

### 2. Product Extraction  
```bash
cd suppliers/{self.supplier_id}/scripts
python {self.supplier_id}_product_extractor.py
```

### 3. LangGraph Integration
```bash
cd suppliers/{self.supplier_id}/scripts
python {self.supplier_id}_langgraph_integration.py
```

## Integration with Main System

Add to LangGraph workflow:
```python
from suppliers.{self.supplier_id}.scripts.{self.supplier_id}_langgraph_integration import setup_{self.supplier_id.replace('-', '_')}_supplier

# In workflow
result = await setup_{self.supplier_id.replace('-', '_')}_supplier(page, credentials)
```

## Generated: {datetime.now().isoformat()}
"""
                
                (self.supplier_dir / "USAGE.md").write_text(usage_content, encoding='utf-8')
                
            else:
                log.error("âŒ Some scripts failed to generate")
            
            return success
            
        except Exception as e:
            log.error(f"âŒ Failed to generate automation package: {e}")
            return False

def main():
    """Main entry point for supplier script generator"""
    parser = argparse.ArgumentParser(description='Generate supplier-specific automation scripts')
    parser.add_argument('--supplier-url', required=True, help='Supplier website URL')
    parser.add_argument('--supplier-name', help='Supplier display name')
    parser.add_argument('--email', help='Login email for testing')
    parser.add_argument('--password', help='Login password for testing')
    parser.add_argument('--force-regenerate', action='store_true', help='Force regeneration even if supplier is ready (creates backup)')
    
    args = parser.parse_args()
    
    # Create generator
    generator = SupplierScriptGenerator(args.supplier_url, args.supplier_name)
    
    # Generate all scripts
    success = generator.generate_all_scripts(force_regenerate=args.force_regenerate)
    
    if success:
        print(f"âœ… SUCCESS: Automation package generated for {generator.supplier_name}")
        print(f"ğŸ“ Location: {generator.supplier_dir}")
        print(f"ğŸ”§ Ready for LangGraph integration")
    else:
        print(f"âŒ FAILED: Could not generate complete automation package")
        exit(1)

if __name__ == "__main__":
    main()