#!/usr/bin/env python3
"""
Poundwholesale Co Uk Login Script
Auto-generated by IntelligentSupplierScriptGenerator on 2025-07-08T17:51:11.181314

Provides login automation for https://www.poundwholesale.co.uk/
"""

import asyncio
import json
import logging
import os
from datetime import datetime
from typing import Dict, Any
from playwright.async_api import async_playwright, Page

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

# Configuration
SUPPLIER_URL = "https://www.poundwholesale.co.uk/"
EMAIL_SELECTOR = "input[type='email']"
PASSWORD_SELECTOR = "input[type='password']"
SUBMIT_SELECTOR = "button[type='submit']"

class Poundwholesale_Co_UkLogin:
    """Login automation for https://www.poundwholesale.co.uk/"""
    
    def __init__(self, email: str, password: str, test_mode: bool = False):
        self.email = email
        self.password = password
        self.test_mode = test_mode
        self.page: Page = None
        self.browser = None
        self.context = None
    
    async def connect_to_browser(self) -> bool:
        """Connect to existing Chrome debug instance"""
        try:
            playwright = await async_playwright().start()
            self.browser = await playwright.chromium.connect_over_cdp("http://localhost:9222")
            
            if self.browser.contexts:
                self.context = self.browser.contexts[0]
            else:
                self.context = await self.browser.new_context()
            
            if self.context.pages:
                self.page = self.context.pages[0]
            else:
                self.page = await self.context.new_page()
                
            await self.page.bring_to_front()
            return True
            
        except Exception as e:
            log.error(f"Failed to connect to browser: {e}")
            return False
    
    async def check_login_status(self) -> bool:
        """Check if already logged in"""
        try:
            await self.page.goto(SUPPLIER_URL)
            await self.page.wait_for_load_state('domcontentloaded')
            
            # Look for logout indicators or account areas
            logout_indicators = [
                "text=logout", "text=sign out", "text=my account", 
                ".logout", ".signout", ".account"
            ]
            
            for indicator in logout_indicators:
                try:
                    element = await self.page.query_selector(indicator)
                    if element and await element.is_visible():
                        log.info("âœ… Already logged in")
                        return True
                except:
                    continue
            
            log.info("âŒ Not logged in")
            return False
            
        except Exception as e:
            log.error(f"Failed to check login status: {e}")
            return False
    
    async def perform_login(self) -> Dict[str, Any]:
        """Perform login sequence"""
        try:
            log.info(f"ðŸ” Starting login to {SUPPLIER_URL}")
            
            # Check if already logged in
            if await self.check_login_status():
                return {"success": True, "message": "Already logged in", "action": "none"}
            
            # Try to trigger login modal/form first
            login_triggers = [
                "text=login", "text=sign in", "text=log in", 
                ".login", ".signin", "#login", "#signin",
                "[data-action='customer-account-login']",
                "a[href*='login']", "a[href*='account']"
            ]
            
            login_form_visible = False
            for trigger in login_triggers:
                try:
                    element = await self.page.query_selector(trigger)
                    if element and await element.is_visible():
                        log.info(f"ðŸ”— Clicking login trigger: {trigger}")
                        await element.click()
                        await self.page.wait_for_timeout(2000)  # Wait for form to appear
                        
                        # Check if password field is now visible
                        password_element = await self.page.query_selector(PASSWORD_SELECTOR)
                        if password_element and await password_element.is_visible():
                            login_form_visible = True
                            break
                except:
                    continue
            
            # If no login form visible, try common modal triggers
            if not login_form_visible:
                modal_triggers = [
                    "text=Account", "text=My Account", ".customer-welcome",
                    "[data-toggle='modal']", ".modal-trigger"
                ]
                for trigger in modal_triggers:
                    try:
                        element = await self.page.query_selector(trigger)
                        if element and await element.is_visible():
                            log.info(f"ðŸ”— Clicking modal trigger: {trigger}")
                            await element.click()
                            await self.page.wait_for_timeout(2000)
                            
                            # Check again for password field
                            password_element = await self.page.query_selector(PASSWORD_SELECTOR)
                            if password_element and await password_element.is_visible():
                                login_form_visible = True
                                break
                    except:
                        continue
            
            # Fill email field
            try:
                await self.page.fill(EMAIL_SELECTOR, self.email)
                log.info("âœ… Email filled")
            except Exception as e:
                log.error(f"Failed to fill email: {e}")
                if self.test_mode:
                    return {"success": False, "error": f"Email selector failed: {EMAIL_SELECTOR}", "step": "email"}
                raise
            
            # Wait a moment and try to make password field visible
            await self.page.wait_for_timeout(1000)
            
            # Fill password field with enhanced error handling
            try:
                # First check if password field exists and is visible
                password_element = await self.page.query_selector(PASSWORD_SELECTOR)
                if password_element:
                    # Try to scroll into view and make visible
                    await password_element.scroll_into_view_if_needed()
                    await self.page.wait_for_timeout(500)
                    
                    # Check if visible now
                    if await password_element.is_visible():
                        await self.page.fill(PASSWORD_SELECTOR, self.password)
                        log.info("âœ… Password filled")
                    else:
                        log.warning("âš ï¸ Password field exists but not visible, attempting force fill")
                        await password_element.fill(self.password)
                        log.info("âœ… Password force-filled")
                else:
                    raise Exception(f"Password field not found: {PASSWORD_SELECTOR}")
                    
            except Exception as e:
                log.error(f"Failed to fill password: {e}")
                if self.test_mode:
                    return {"success": False, "error": f"Password selector failed: {PASSWORD_SELECTOR}", "step": "password"}
                raise
            
            # Click submit button
            try:
                await self.page.click(SUBMIT_SELECTOR)
                log.info("âœ… Submit button clicked")
            except Exception as e:
                log.error(f"Failed to click submit: {e}")
                if self.test_mode:
                    return {"success": False, "error": f"Submit selector failed: {SUBMIT_SELECTOR}", "step": "submit"}
                raise
            
            # Wait for navigation or login completion
            try:
                await self.page.wait_for_load_state('domcontentloaded', timeout=10000)
            except:
                pass  # Continue even if timeout
            
            # Verify login success
            if await self.check_login_status():
                log.info("âœ… Login successful")
                return {"success": True, "message": "Login completed successfully"}
            else:
                log.error("âŒ Login failed - still not logged in")
                return {"success": False, "error": "Login failed - verification check failed", "step": "verification"}
                
        except Exception as e:
            log.error(f"Login failed: {e}")
            return {"success": False, "error": str(e), "step": "unknown"}

# Test function for validation
async def test_login(email: str, password: str) -> Dict[str, Any]:
    """Test login functionality"""
    try:
        login_handler = Poundwholesale_Co_UkLogin(email, password, test_mode=True)
        
        if not await login_handler.connect_to_browser():
            return {"success": False, "error": "Failed to connect to browser"}
        
        result = await login_handler.perform_login()
        return result
        
    except Exception as e:
        return {"success": False, "error": str(e)}

if __name__ == "__main__":
    # Test mode execution
    import sys
    if len(sys.argv) >= 3:
        email = sys.argv[1]
        password = sys.argv[2]
        result = asyncio.run(test_login(email, password))
        print(json.dumps(result, indent=2))
    else:
        print("Usage: python {__file__} <email> <password>")
