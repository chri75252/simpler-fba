#!/usr/bin/env python3
"""
Poundwholesale Co Uk Login Script
Auto-generated by IntelligentSupplierScriptGenerator on 2025-07-08T18:44:49.043316

Provides login automation for https://www.poundwholesale.co.uk/
"""

import asyncio
import json
import logging
import os
from datetime import datetime
from typing import Dict, Any
from playwright.async_api import async_playwright, Page
import openai

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

# Configuration
SUPPLIER_URL = "https://www.poundwholesale.co.uk/"
EMAIL_SELECTOR = "input[type='email']"
PASSWORD_SELECTOR = "input[type='password']"
SUBMIT_SELECTOR = ".btn.btn-primary.btn-block, button:has-text('Login'), button:has-text('Sign in'), button[type='submit'], .btn.btn-primary, .btn-primary, input[type='submit']"

class Poundwholesale_Co_UkLogin:
    """Login automation for https://www.poundwholesale.co.uk/"""
    
    def __init__(self, email: str, password: str, test_mode: bool = False):
        self.email = email
        self.password = password
        self.test_mode = test_mode
        self.page: Page = None
        self.browser = None
        self.context = None
        self.openai_client = openai.OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
        self.supplier_url = SUPPLIER_URL
    
    async def connect_to_browser(self) -> bool:
        """Connect to existing Chrome debug instance"""
        try:
            playwright = await async_playwright().start()
            self.browser = await playwright.chromium.connect_over_cdp("http://localhost:9222")
            
            if self.browser.contexts:
                self.context = self.browser.contexts[0]
            else:
                self.context = await self.browser.new_context()
            
            if self.context.pages:
                self.page = self.context.pages[0]
            else:
                self.page = await self.context.new_page()
                
            await self.page.bring_to_front()
            return True
            
        except Exception as e:
            log.error(f"Failed to connect to browser: {e}")
            return False
    
    async def check_login_status(self) -> bool:
        """Check if already logged in"""
        try:
            await self.page.goto(SUPPLIER_URL)
            await self.page.wait_for_load_state('domcontentloaded')
            
            # Look for logout indicators or account areas
            logout_indicators = [
                "text=logout", "text=sign out", "text=my account", 
                ".logout", ".signout", ".account"
            ]
            
            for indicator in logout_indicators:
                try:
                    element = await self.page.query_selector(indicator)
                    if element and await element.is_visible():
                        log.info("âœ… Already logged in")
                        return True
                except:
                    continue
            
            log.info("âŒ Not logged in")
            return False
            
        except Exception as e:
            log.error(f"Failed to check login status: {e}")
            return False
    
    async def perform_login(self) -> Dict[str, Any]:
        """Perform login sequence"""
        try:
            log.info(f"ðŸ” Starting login to {SUPPLIER_URL}")
            
            # Check if already logged in
            if await self.check_login_status():
                return {"success": True, "message": "Already logged in", "action": "none"}
            
            # Try to trigger login modal/form first
            login_triggers = [
                # More specific selectors targeting header navigation
                "header a:has-text('Sign in')", "nav a:has-text('Sign in')",
                ".header-links a:has-text('Sign in')", ".customer-welcome a:has-text('Sign in')",
                "a[href*='/customer/account/login']", "a[href*='login']",
                # Fallback to generic if needed
                "text=Register or Sign in", "text=sign in", "text=log in"
            ]
            
            login_form_visible = False
            for trigger in login_triggers:
                try:
                    element = await self.page.query_selector(trigger)
                    if element and await element.is_visible():
                        log.info(f"ðŸ”— Clicking login trigger: {trigger}")
                        await element.click()
                        await self.page.wait_for_timeout(2000)  # Wait for form to appear
                        
                        # Check if password field is now visible
                        password_element = await self.page.query_selector(PASSWORD_SELECTOR)
                        if password_element and await password_element.is_visible():
                            login_form_visible = True
                            break
                except:
                    continue
            
            # If no login form visible, try common modal triggers
            if not login_form_visible:
                modal_triggers = [
                    "text=Account", "text=My Account", ".customer-welcome",
                    "[data-toggle='modal']", ".modal-trigger"
                ]
                for trigger in modal_triggers:
                    try:
                        element = await self.page.query_selector(trigger)
                        if element and await element.is_visible():
                            log.info(f"ðŸ”— Clicking modal trigger: {trigger}")
                            await element.click()
                            await self.page.wait_for_timeout(2000)
                            
                            # Check again for password field
                            password_element = await self.page.query_selector(PASSWORD_SELECTOR)
                            if password_element and await password_element.is_visible():
                                login_form_visible = True
                                break
                    except:
                        continue
            
            # Fill email field
            try:
                await self.page.fill(EMAIL_SELECTOR, self.email)
                log.info("âœ… Email filled")
            except Exception as e:
                log.error(f"Failed to fill email: {e}")
                if self.test_mode:
                    return {"success": False, "error": f"Email selector failed: {EMAIL_SELECTOR}", "step": "email"}
                raise
            
            # Wait a moment and try to make password field visible
            await self.page.wait_for_timeout(1000)
            
            # Fill password field with enhanced error handling
            try:
                # First check if password field exists and is visible
                password_element = await self.page.query_selector(PASSWORD_SELECTOR)
                if password_element:
                    # Try to scroll into view and make visible
                    await password_element.scroll_into_view_if_needed()
                    await self.page.wait_for_timeout(500)
                    
                    # Check if visible now
                    if await password_element.is_visible():
                        await self.page.fill(PASSWORD_SELECTOR, self.password)
                        log.info("âœ… Password filled")
                    else:
                        log.warning("âš ï¸ Password field exists but not visible, attempting force fill")
                        await password_element.fill(self.password)
                        log.info("âœ… Password force-filled")
                else:
                    raise Exception(f"Password field not found: {PASSWORD_SELECTOR}")
                    
            except Exception as e:
                log.error(f"Failed to fill password: {e}")
                if self.test_mode:
                    return {"success": False, "error": f"Password selector failed: {PASSWORD_SELECTOR}", "step": "password"}
                raise
            
            # Click submit button with modal overlay handling
            try:
                # Enhanced modal overlay handling - try multiple approaches
                modal_handled = False
                
                # Method 1: Try to dismiss modal overlays
                modal_close_selectors = [
                    ".modals-overlay", ".modal-backdrop", ".overlay", 
                    "[data-role='backdrop']", ".modal-close", "button[aria-label='Close']"
                ]
                
                for close_selector in modal_close_selectors:
                    try:
                        overlay_element = await self.page.query_selector(close_selector)
                        if overlay_element and await overlay_element.is_visible():
                            log.info(f"ðŸš« Dismissing modal overlay: {close_selector}")
                            await overlay_element.click()
                            await self.page.wait_for_timeout(2000)
                            modal_handled = True
                            break
                    except:
                        continue
                
                # Method 2: If overlay still exists, try to hide it with JavaScript
                if not modal_handled:
                    try:
                        await self.page.evaluate("""() => {
                            const overlays = document.querySelectorAll('.modals-overlay, .modal-backdrop, .overlay');
                            overlays.forEach(overlay => {
                                overlay.style.display = 'none';
                                overlay.style.visibility = 'hidden';
                                overlay.style.pointerEvents = 'none';
                            });
                        }""")
                        log.info("ðŸš« Forcibly hid modal overlays with JavaScript")
                        await self.page.wait_for_timeout(1000)
                    except Exception as e:
                        log.warning(f"Failed to hide overlays with JavaScript: {e}")
                
                # Method 3: Ensure submit button is visible and clickable
                try:
                    await self.page.evaluate("""() => {
                        const submitBtn = document.querySelector('.btn.btn-primary.btn-block, button[type="submit"]');
                        if (submitBtn) {
                            submitBtn.style.zIndex = '99999';
                            submitBtn.style.position = 'relative';
                        }
                    }""")
                    log.info("ðŸŽ¯ Enhanced submit button visibility")
                except:
                    pass
                
                # Try normal click first
                try:
                    await self.page.click(SUBMIT_SELECTOR)
                    log.info("âœ… Submit button clicked")
                except Exception as click_error:
                    log.warning(f"Normal click failed: {click_error}, trying force click")
                    # Try force click to bypass modal overlays
                    submit_element = await self.page.query_selector(SUBMIT_SELECTOR)
                    if submit_element:
                        await submit_element.click(force=True)
                        log.info("âœ… Submit button force-clicked")
                    else:
                        raise Exception(f"Submit button not found: {SUBMIT_SELECTOR}")
                        
            except Exception as e:
                log.error(f"Failed to click submit: {e}")
                if self.test_mode:
                    return {"success": False, "error": f"Submit selector failed: {SUBMIT_SELECTOR}", "step": "submit"}
                raise
            
            # Wait for navigation or login completion
            try:
                await self.page.wait_for_load_state('domcontentloaded', timeout=10000)
            except:
                pass  # Continue even if timeout
            
            # Verify login success
            if await self.check_login_status():
                log.info("âœ… Login successful")
                return {"success": True, "message": "Login completed successfully"}
            else:
                log.warning("âŒ Login verification failed - analyzing current page state...")
                
                # CRITICAL FALLBACK: Analyze what happened after submit click
                try:
                    # Take screenshot for visual analysis
                    screenshot_path = f"logs/debug/login_failure_screenshot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                    await self.page.screenshot(path=screenshot_path, full_page=True)
                    log.info(f"ðŸ“¸ Screenshot saved: {screenshot_path}")
                    
                    # Get current page HTML for analysis
                    current_html = await self.page.content()
                    log.info(f"ðŸ“„ Current page HTML length: {len(current_html)} characters")
                    
                    # Check for common login error indicators
                    error_indicators = [
                        "invalid", "incorrect", "wrong", "error", "failed", 
                        "captcha", "blocked", "suspended", "verification required",
                        "two-factor", "2fa", "code", "security"
                    ]
                    
                    page_text = await self.page.inner_text("body")
                    found_errors = []
                    for indicator in error_indicators:
                        if indicator.lower() in page_text.lower():
                            found_errors.append(indicator)
                    
                    if found_errors:
                        log.warning(f"ðŸš¨ Detected potential error indicators: {found_errors}")
                        return {
                            "success": False, 
                            "error": f"Login failed - detected errors: {found_errors}", 
                            "step": "verification",
                            "analysis": {
                                "screenshot": screenshot_path,
                                "html_length": len(current_html),
                                "error_indicators": found_errors,
                                "current_url": await self.page.url,
                                "page_title": await self.page.title()
                            }
                        }
                    
                    # Check if we're on a different page (potential redirect)
                    current_url = await self.page.url
                    if current_url != SUPPLIER_URL:
                        log.info(f"ðŸ”„ Page redirected to: {current_url}")
                        # Re-check login status on new page
                        if await self.check_login_status():
                            log.info("âœ… Login successful after redirect")
                            return {"success": True, "message": "Login completed successfully after redirect"}
                    
                    # Use AI to analyze the failure state
                    ai_analysis = await self._analyze_login_failure_with_ai(screenshot_path, current_html, current_url)
                    
                    # Provide comprehensive failure analysis
                    return {
                        "success": False,
                        "error": "Login verification failed - no clear error indicators found",
                        "step": "verification", 
                        "analysis": {
                            "screenshot": screenshot_path,
                            "html_length": len(current_html),
                            "current_url": current_url,
                            "page_title": await self.page.title(),
                            "ai_analysis": ai_analysis,
                            "suggestion": "Review AI analysis and screenshot for next steps"
                        }
                    }
                    
                except Exception as analysis_error:
                    log.error(f"Failed to analyze login failure: {analysis_error}")
                    return {
                        "success": False, 
                        "error": f"Login failed and analysis failed: {analysis_error}", 
                        "step": "verification"
                    }
                
        except Exception as e:
            log.error(f"Login failed: {e}")
            return {"success": False, "error": str(e), "step": "unknown"}
    
    async def _analyze_login_failure_with_ai(self, screenshot_path: str, html_content: str, current_url: str) -> str:
        """Use AI to analyze login failure state with screenshot and HTML"""
        try:
            import base64
            
            # Read and encode screenshot
            with open(screenshot_path, 'rb') as img_file:
                screenshot_base64 = base64.b64encode(img_file.read()).decode('utf-8')
            
            # Prepare HTML snippet (first 5000 chars to avoid token limits)
            html_snippet = html_content[:5000] if len(html_content) > 5000 else html_content
            
            analysis_prompt = f"""
            CRITICAL LOGIN FAILURE ANALYSIS:
            
            URL: {current_url}
            Supplier: {self.supplier_url}
            
            I attempted to login but verification failed. Please analyze the screenshot and HTML to determine:
            
            1. What state is the page in after login attempt?
            2. Are there any error messages visible?
            3. Did login succeed but verification logic fail?
            4. Are there additional steps needed (CAPTCHA, 2FA, etc.)?
            5. What should be the next action to resolve this?
            
            HTML START:
            {html_snippet}
            HTML END
            
            Please provide a clear, actionable diagnosis of what went wrong and what to try next.
            """
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": analysis_prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/png;base64,{screenshot_base64}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=500,
                temperature=0.1
            )
            
            ai_diagnosis = response.choices[0].message.content
            log.info(f"ðŸ¤– AI Login Failure Analysis: {ai_diagnosis}")
            return ai_diagnosis
            
        except Exception as e:
            log.error(f"AI analysis failed: {e}")
            return f"AI analysis failed: {e}"

# Test function for validation
async def test_login(email: str, password: str) -> Dict[str, Any]:
    """Test login functionality"""
    try:
        login_handler = Poundwholesale_Co_UkLogin(email, password, test_mode=True)
        
        if not await login_handler.connect_to_browser():
            return {"success": False, "error": "Failed to connect to browser"}
        
        result = await login_handler.perform_login()
        return result
        
    except Exception as e:
        return {"success": False, "error": str(e)}

if __name__ == "__main__":
    # Test mode execution
    import sys
    if len(sys.argv) >= 3:
        email = sys.argv[1]
        password = sys.argv[2]
        result = asyncio.run(test_login(email, password))
        print(json.dumps(result, indent=2))
    else:
        print("Usage: python {__file__} <email> <password>")
